{"name":"currency-exchange","input":{"kind":"schema","type":"variant","reference":"function variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: !1,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset, maxDiscriminatorPriority = 0, invalidDiscriminatorKey = this.key, expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\")\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            else {\n              let keysAreValid = !0, currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey][\"~run\"]({ typed: !1, value: input[currentKey] }, config2).issues) {\n                  keysAreValid = !1;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && (currentKey in input) && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey)\n                    expectedDiscriminators.push(schema.entries[currentKey].expects);\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed)\n                  outputDataset = optionDataset;\n              }\n            }\n            if (outputDataset && !outputDataset.issues)\n              break;\n          }\n        };\n        parseOptions(this, new Set([this.key]));\n        if (outputDataset)\n          return outputDataset;\n        _addIssue(this, \"type\", dataset, config2, {\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"Object","async":false,"key":"date","options":[{"kind":"schema","type":"strict_object","reference":"function strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: !1,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = !0;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key], valueDataset = this.entries[key][\"~run\"]({ value: value2 }, config2);\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path)\n                issue.path.unshift(pathItem);\n              else\n                issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues)\n              dataset.issues = valueDataset.issues;\n            if (config2.abortEarly) {\n              dataset.typed = !1;\n              break;\n            }\n          }\n          if (!valueDataset.typed)\n            dataset.typed = !1;\n          if (valueDataset.value !== void 0 || key in input)\n            dataset.value[key] = valueDataset.value;\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input)\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n        }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"Object","async":false,"entries":{"date":{"kind":"schema","type":"date","reference":"function date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: !1,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date)\n        if (!isNaN(dataset.value))\n          dataset.typed = !0;\n        else\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"Date","async":false,"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date)\n        if (!isNaN(dataset.value))\n          dataset.typed = !0;\n        else\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"from":{"kind":"schema","type":"picklist","reference":"function picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: !1,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"(\"eur\" | \"usd\" | \"chf\" | \"gbp\")","async":false,"options":["eur","usd","chf","gbp"],"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"to":{"kind":"schema","type":"array","reference":"function array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: !1,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = !0;\n        dataset.value = [];\n        for (let key = 0;key < input.length; key++) {\n          const value2 = input[key], itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path)\n                issue.path.unshift(pathItem);\n              else\n                issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues)\n              dataset.issues = itemDataset.issues;\n            if (config2.abortEarly) {\n              dataset.typed = !1;\n              break;\n            }\n          }\n          if (!itemDataset.typed)\n            dataset.typed = !1;\n          dataset.value.push(itemDataset.value);\n        }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"Array","async":false,"item":{"kind":"schema","type":"picklist","reference":"function picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: !1,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"(\"eur\" | \"usd\" | \"chf\" | \"gbp\")","async":false,"options":["eur","usd","chf","gbp"],"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = !0;\n        dataset.value = [];\n        for (let key = 0;key < input.length; key++) {\n          const value2 = input[key], itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path)\n                issue.path.unshift(pathItem);\n              else\n                issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues)\n              dataset.issues = itemDataset.issues;\n            if (config2.abortEarly) {\n              dataset.typed = !1;\n              break;\n            }\n          }\n          if (!itemDataset.typed)\n            dataset.typed = !1;\n          dataset.value.push(itemDataset.value);\n        }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"value":{"kind":"schema","type":"number","reference":"function number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: !1,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"number","async":false,"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"}},"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = !0;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key], valueDataset = this.entries[key][\"~run\"]({ value: value2 }, config2);\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path)\n                issue.path.unshift(pathItem);\n              else\n                issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues)\n              dataset.issues = valueDataset.issues;\n            if (config2.abortEarly) {\n              dataset.typed = !1;\n              break;\n            }\n          }\n          if (!valueDataset.typed)\n            dataset.typed = !1;\n          if (valueDataset.value !== void 0 || key in input)\n            dataset.value[key] = valueDataset.value;\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input)\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n        }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},{"kind":"schema","type":"strict_object","reference":"function strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: !1,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = !0;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key], valueDataset = this.entries[key][\"~run\"]({ value: value2 }, config2);\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path)\n                issue.path.unshift(pathItem);\n              else\n                issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues)\n              dataset.issues = valueDataset.issues;\n            if (config2.abortEarly) {\n              dataset.typed = !1;\n              break;\n            }\n          }\n          if (!valueDataset.typed)\n            dataset.typed = !1;\n          if (valueDataset.value !== void 0 || key in input)\n            dataset.value[key] = valueDataset.value;\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input)\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n        }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"Object","async":false,"entries":{"date":{"kind":"schema","type":"literal","reference":"function literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: !1,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal)\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"\"latest\"","async":false,"literal":"latest","~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (dataset.value === this.literal)\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"from":{"kind":"schema","type":"picklist","reference":"function picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: !1,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"(\"eur\" | \"usd\" | \"chf\" | \"gbp\")","async":false,"options":["eur","usd","chf","gbp"],"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"to":{"kind":"schema","type":"array","reference":"function array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: !1,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = !0;\n        dataset.value = [];\n        for (let key = 0;key < input.length; key++) {\n          const value2 = input[key], itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path)\n                issue.path.unshift(pathItem);\n              else\n                issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues)\n              dataset.issues = itemDataset.issues;\n            if (config2.abortEarly) {\n              dataset.typed = !1;\n              break;\n            }\n          }\n          if (!itemDataset.typed)\n            dataset.typed = !1;\n          dataset.value.push(itemDataset.value);\n        }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"Array","async":false,"item":{"kind":"schema","type":"picklist","reference":"function picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: !1,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"(\"eur\" | \"usd\" | \"chf\" | \"gbp\")","async":false,"options":["eur","usd","chf","gbp"],"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = !0;\n        dataset.value = [];\n        for (let key = 0;key < input.length; key++) {\n          const value2 = input[key], itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path)\n                issue.path.unshift(pathItem);\n              else\n                issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues)\n              dataset.issues = itemDataset.issues;\n            if (config2.abortEarly) {\n              dataset.typed = !1;\n              break;\n            }\n          }\n          if (!itemDataset.typed)\n            dataset.typed = !1;\n          dataset.value.push(itemDataset.value);\n        }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"value":{"kind":"schema","type":"number","reference":"function number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: !1,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"number","async":false,"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"}},"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = !0;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key], valueDataset = this.entries[key][\"~run\"]({ value: value2 }, config2);\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path)\n                issue.path.unshift(pathItem);\n              else\n                issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues)\n              dataset.issues = valueDataset.issues;\n            if (config2.abortEarly) {\n              dataset.typed = !1;\n              break;\n            }\n          }\n          if (!valueDataset.typed)\n            dataset.typed = !1;\n          if (valueDataset.value !== void 0 || key in input)\n            dataset.value[key] = valueDataset.value;\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input)\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n        }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"}],"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset, maxDiscriminatorPriority = 0, invalidDiscriminatorKey = this.key, expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\")\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            else {\n              let keysAreValid = !0, currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey][\"~run\"]({ typed: !1, value: input[currentKey] }, config2).issues) {\n                  keysAreValid = !1;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && (currentKey in input) && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey)\n                    expectedDiscriminators.push(schema.entries[currentKey].expects);\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed)\n                  outputDataset = optionDataset;\n              }\n            }\n            if (outputDataset && !outputDataset.issues)\n              break;\n          }\n        };\n        parseOptions(this, new Set([this.key]));\n        if (outputDataset)\n          return outputDataset;\n        _addIssue(this, \"type\", dataset, config2, {\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"fn":"async (input) => {\n    let date = \"latest\", dateFallback = \"latest\";\n    if (input.date !== \"latest\") {\n      date = `${input.date.getFullYear()}.${input.date.getMonth() + 1}.${input.date.getDate()}`;\n      dateFallback = `${input.date.getFullYear()}-${input.date.getMonth() + 1}-${input.date.getDate()}`;\n    }\n    console.log(`Fetching data for ${input.from} to (${input.to.join(\", \")}) on ${date}`);\n    const url = `https://${dateFallback}.currency-api.pages.dev/v1/currencies/${input.from.toLowerCase()}.json`, fallbackUrl = `https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@${date}/v1/currencies/${input.from.toLowerCase()}.json`;\n    let workingUrl = url;\n    console.log(`Loading data from ${workingUrl}`);\n    let response = await fetch(url);\n    if (!response.ok) {\n      workingUrl = fallbackUrl;\n      console.log(`Loading data from ${workingUrl}`);\n      response = await fetch(fallbackUrl);\n    }\n    if (!response.ok) {\n      workingUrl = \"failed:\" + fallbackUrl;\n      throw new Error(\"Could not fetch data\");\n    }\n    const data = await response.json();\n    if (!data)\n      throw new Error(\"Could not fetch data\");\n    if (!Object.hasOwn(data, input.from.toLowerCase()))\n      throw new Error(\"Could not find from currency\");\n    const from = data[input.from.toLowerCase()], result = Object.create({});\n    for (const to of input.to) {\n      if (!Object.hasOwn(from, to.toLowerCase()))\n        throw new Error(\"Could not find to currency\");\n      result[to] = from[to.toLowerCase()] * input.value;\n    }\n    result[input.from] = input.value;\n    return result;\n  }","outputs":{"success":{"kind":"schema","type":"record","reference":"function record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: !1,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = !0;\n        dataset.value = {};\n        for (const entryKey in input)\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey], keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues)\n                dataset.issues = keyDataset.issues;\n              if (config2.abortEarly) {\n                dataset.typed = !1;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"]({ value: entryValue }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path)\n                  issue.path.unshift(pathItem);\n                else\n                  issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues)\n                dataset.issues = valueDataset.issues;\n              if (config2.abortEarly) {\n                dataset.typed = !1;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed)\n              dataset.typed = !1;\n            if (keyDataset.typed)\n              dataset.value[keyDataset.value] = valueDataset.value;\n          }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"Object","async":false,"key":{"kind":"schema","type":"picklist","reference":"function picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: !1,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"(\"eur\" | \"usd\" | \"chf\" | \"gbp\")","async":false,"options":["eur","usd","chf","gbp"],"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"value":{"kind":"schema","type":"number","reference":"function number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: !1,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}","expects":"number","async":false,"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value))\n        dataset.typed = !0;\n      else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = !0;\n        dataset.value = {};\n        for (const entryKey in input)\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey], keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues)\n                dataset.issues = keyDataset.issues;\n              if (config2.abortEarly) {\n                dataset.typed = !1;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"]({ value: entryValue }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path)\n                  issue.path.unshift(pathItem);\n                else\n                  issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues)\n                dataset.issues = valueDataset.issues;\n              if (config2.abortEarly) {\n                dataset.typed = !1;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed)\n              dataset.typed = !1;\n            if (keyDataset.typed)\n              dataset.value[keyDataset.value] = valueDataset.value;\n          }\n      } else\n        _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }"},"error":{"kind":"schema","type":"any","reference":"function any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: !1,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = !0;\n      return dataset;\n    }\n  };\n}","expects":"any","async":false,"~standard":{"version":1,"vendor":"valibot","validate":"validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }"},"~run":"\"~run\"(dataset) {\n      dataset.typed = !0;\n      return dataset;\n    }"}}}